{"note":"Don't delete this file! It's used internally to help with page regeneration.","body":"# Periscope [![Build Status](https://secure.travis-ci.org/laserlemon/periscope.png)](http://travis-ci.org/laserlemon/periscope) [![Dependency Status](https://gemnasium.com/laserlemon/periscope.png)](https://gemnasium.com/laserlemon/periscope)\r\n\r\nPeriscope provides a simple way to chain scopes on your models and to open those scopes up to your users.\r\n\r\n## Installation\r\n\r\nPeriscope sits on top of your favorite ORM. Currently, the following ORMs are supported through individual gems extending Periscope:\r\n\r\n* Active Record ([periscope-activerecord](https://rubygems.org/gems/periscope-activerecord))\r\n* MongoMapper ([periscope-mongo_mapper](https://rubygems.org/gems/periscope-mongo_mapper))\r\n* Mongoid ([periscope-mongoid](https://rubygems.org/gems/periscope-mongoid))\r\n* DataMapper ([periscope-data_mapper](https://rubygems.org/gems/periscope-data_mapper))\r\n\r\nSimply add the gem to your bundle and you're off!\r\n\r\n## The Problem\r\n\r\nMore often than not, the index action in a RESTful Rails controller is expected to do a lot more than simply return all the records for a given model. We ask it to do all sorts of stuff like filtering, sorting and paginating results. Of course, this is typically done using _scopes_.\r\n\r\nBut it can get ugly building long, complicated chains of scopes in the controller, especially when you try to give your users control over the scoping. Picture this:\r\n\r\n```ruby\r\ndef index\r\n  @articles = Article.scoped\r\n  @articles = @articles.published_after(params[:published_after]) if params.key?(:published_after)\r\n  @articles = @articles.published_before(params[:published_before]) if params.key?(:published_before)\r\nend\r\n```\r\n\r\nYou can imagine how bad this would get if more than two scopes were involved.\r\n\r\n## The Solution\r\n\r\nWith Periscope, you can have this instead:\r\n\r\n```ruby\r\ndef index\r\n  @articles = Article.periscope(request.query_parameters)\r\nend\r\n```\r\n\r\nThe `periscope` method will find keys in your params matching your scope names and chain your scopes for you.\r\n\r\n**Note:** We're using `request.query_parameters` so that we can exclude our controller and action params. `request.query_parameters` will just return the params that appear in the query string.\r\n\r\n## But Wait!\r\n\r\n\"What if I don't want to make all my scopes publicly accessible?\"\r\n\r\nWithin your model you can use the `scope_accessible` method to specify which scopes you want Periscope to honor.\r\n\r\n```ruby\r\nclass User < ActiveRecord::Base\r\n  scope :gender, lambda{|g| where(gender: g) }\r\n  scope :makes, lambda{|s| where('salary >= ?', s) }\r\n\r\n  scope_accessible :gender\r\nend\r\n```\r\n\r\nAnd in your controller:\r\n\r\n```ruby\r\nclass UsersController < ApplicationController\r\n  def index\r\n    @users = User.periscope(request.query_parameters)\r\n  end\r\nend\r\n```\r\n\r\nRequests to `/users?gender=male` will filter results to only male users. But a request to `/users?makes=1000000` will return all users, silently ignoring the protected scope.\r\n\r\nBy default, all scopes are protected.\r\n\r\n## There's More!\r\n\r\n### Custom Parameter Parsing\r\n\r\nSometimes the values you get from the query parameters aren't quite good enough. They may need to be massaged in order to work with your scopes and class methods. In those cases, you can provide a `:parser` option to your `scope_accessible` method.\r\n\r\nParsers must respond to the `call` method, receiving the raw query parameter and returning an array of arguments to pass to the scope or class method.\r\n\r\n```ruby\r\nclass User < ActiveRecord::Base\r\n  scope :gender, lambda{|g| where(gender: g) }\r\n\r\n  scope_accessible :gender, parser: lambda{|g| [g.downcase] }\r\nend\r\n```\r\n\r\n### On/Off Scopes\r\n\r\nBut not all scopes accept arguments. For scopes that you want to toggle on or off, you can set a `:boolean => true` option. Whenever the received parameter is truthy, the scope will be applied. Otherwise, it will be skipped.\r\n\r\n```ruby\r\nclass User < ActiveRecord::Base\r\n  scope :male, where(gender: 'male')\r\n  scope :female, where(gender: 'female')\r\n\r\n  scope_accessible :male, :female, boolean: true\r\nend\r\n```\r\n\r\n### Custom Method Names\r\n\r\nSometimes the query parameters you want to open up to your users may collide with existing method names or reserved Ruby words. In order to avoid collision, you can set a `:method` option to specify what method to use for a query parameter.\r\n\r\n```ruby\r\nclass Project < ActiveRecord::Base\r\n  scope_accessible :begin, method: :begins_after\r\n  scope_accessible :end, method: :ends_before\r\n\r\n  def self.begins_after(date)\r\n    where('begins_at >= ?', date)\r\n  end\r\n\r\n  def self.ends_before(date)\r\n    where('ends_at <= ?', date)\r\n  end\r\nend\r\n```\r\n\r\nAlternatively, you can set `:prefix` and/or `:suffix` options, which will be applied to the query parameter name to determine the corresponding method name.\r\n\r\n```ruby\r\nclass Project < ActiveRecord::Base\r\n  scope_accessible :begin, :end, suffix: '_date'\r\n\r\n  def self.begin_date(date)\r\n    where('begins_at >= ?', date)\r\n  end\r\n\r\n  def self.end_date(date)\r\n    where('ends_at <= ?', date)\r\n  end\r\nend\r\n```\r\n\r\n## This sucks.\r\n\r\nHow can I make it better?\r\n\r\n1. Fork it.\r\n2. Make it better.\r\n3. Send me a pull request.\r\n","name":"Periscope","google":"","tagline":"Push your models' scopes up to the surface."}